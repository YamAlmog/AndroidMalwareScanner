import pandas as pd
from typing import Optional
import os
from fastapi import FastAPI, File, UploadFile, HTTPException
from errors import ApkAnalyzerError
from apk_analyzer import ApkAnalyzer
from classifier import Classifier
from typing import List
from errors import CacheException, OtherProvidersException, NonApkFileError, FileNotFoundError
from cache import FilesCacheManager, OtherProviders
from models import ClassificationResponse, Metadata, OtherProvidersClassifications
from redis_cache import RedisCacheManager
import logging
import time
import asyncio
import zipfile
from io import BytesIO
from dotenv import load_dotenv
load_dotenv()

logging.basicConfig(filename='app.log',level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

app = FastAPI()

USER_FILE_PATH = os.getenv('USER_FILE_PATH')
COMMON_PERMISSIONS_PATH = os.getenv('COMMON_PERMISSIONS_PATH_FROM_SRC')
CSV_PATH = os.getenv('CSV_PATH_FROM_SRC')
VT_API_KEY = os.getenv('VT_API_KEY')
VT_URL = os.getenv("VT_URL")
CLOUDM_API_KEY = os.getenv('CLOUDM_API_KEY')

most_common_permissions = pd.read_csv(COMMON_PERMISSIONS_PATH, header=None)
permissions_list = most_common_permissions[0].tolist()[1:]
db_params = {
            'host': os.getenv('HOST'), 
            'database': 'Learning',  
            'user': os.getenv('USER_NAME'), 
            'password': os.getenv('PASSWORD'), 
            }
HOST = os.getenv("REDIS_HOST")
PORT =  os.getenv("REDIS_PORT")

# initial class objects:
apk_analyzer = ApkAnalyzer(permissions_list)

redis_cache = RedisCacheManager(HOST, PORT)

def tracer(func):
    def wrapper(*args):
        logging.debug(f"{func.__name__} function")
        before = time.time()
        result  = func(*args)
        logging.debug(f"====================> Execution time: {time.time() - before} seconds")
        return result
    return wrapper



@tracer
def get_file_details(file_content):
    file_hash = apk_analyzer.get_file_hash(file_content)
    cache_result = redis_cache.get_redis_db_file_details(file_hash)  
   
    if cache_result:
        return cache_result   
    else:
        file_feature_vector = apk_analyzer.get_feature_vector(file_content)
        file_classifier = Classifier(CSV_PATH)
        classification, probability = file_classifier.predict_file(file_feature_vector)
        permissions = apk_analyzer.get_file_permissions(file_content)
        permissions = str(permissions).replace('\'', '')
        # Item doesn't exist, create Classification model and insert it into redis_cache
        file_metadata = Metadata(file_hash = file_hash, permissions = permissions)
        classification_model = ClassificationResponse(verdict = classification, probability = probability, metadata = file_metadata)
        redis_cache.insert_file_details_to_redis_db(file_hash, classification_model)
    return classification_model


def is_apk(contents: bytes):
    # Check for ZIP file signature (APK is essentially a ZIP file)
    try:
        with zipfile.ZipFile(BytesIO(contents)) as zip_file:
            # Check if there's an AndroidManifest.xml file in the ZIP archive
            return "AndroidManifest.xml" in zip_file.namelist()
    except zipfile.BadZipFile:
        return False
    

@app.post("/scan_file")
async def upload_user_file(file: UploadFile = File(...), metadata: Optional[bool]=False):
    try:
        contents = await file.read()
        if is_apk(contents):
            classification_model = get_file_details(contents)
            # return response
            if metadata == True:     
                return classification_model.model_dump(exclude_none=True) # drop none values from response
            else:
                classification_model.metadata = None
                return classification_model.model_dump(exclude_none=True) # drop none values from response
        else:
            raise NonApkFileError(f"Inserting a non-apk file: {file.filename}")
    except NonApkFileError as e:
        raise HTTPException(status_code=400, detail=str(e))    
    except CacheException as e:
        raise HTTPException(status_code=404, detail=str(e))    
    except OSError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except ApkAnalyzerError as e: 
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail= f"Unknown Error: {e}")


@app.post("/get_permissions")
async def get_file_permissions(file: UploadFile = File(...)):
    try:
        contents = await file.read()
        if is_apk(contents):
            permissions = apk_analyzer.get_file_permissions(contents)
            return {'File Permissions': permissions}
        raise NonApkFileError(f"Inserting a non-apk file: {file.filename}")
    except NonApkFileError as e:
        raise HTTPException(status_code=400, detail=str(e))    
    except ApkAnalyzerError as e: 
        raise HTTPException(status_code=401, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail= f"Unknown Error: {e}")



@app.get("/scan_file_with_hash")
async def get_user_file(file_hash: str):
    try:
        file_details = redis_cache.get_redis_db_file_details(file_hash)
        if file_details:
            return file_details.model_dump(exclude_none=True) # drop none values from response
        else:
            raise FileNotFoundError("File hash not found")
    except FileNotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))      
    except CacheException as e:
        raise HTTPException(status_code=404, detail=str(e))     
    except Exception as e:
        raise HTTPException(status_code=500, detail= f"Unknown Error: {e}")



def add_other_providers_to_model(model:ClassificationResponse):
    file_metadata = model.metadata
    file_hash = file_metadata.file_hash
    vt_params = {'apikey': VT_API_KEY, 'resource': file_hash}
    vt_result = OtherProviders.scan_with_virustotal(VT_URL, vt_params)
    model.other_providers = OtherProvidersClassifications(VirusTotal = vt_result)
    return model



@app.post("/scan_with_other_providers")
async def scan_file_with_other_providers(file: UploadFile = File(...)):
    try:
        contents = await file.read()
        if is_apk(contents):    
            classification_model = get_file_details(contents)
        
            classification_model = add_other_providers_to_model(classification_model)
            return classification_model.model_dump(exclude_none=True) # drop none values from response
        else:
            raise NonApkFileError(f"Inserting a non-apk file: {file.filename}")
    except NonApkFileError as e:
        raise HTTPException(status_code=400, detail=str(e))    
    except CacheException as e:
        raise HTTPException(status_code=404, detail=str(e))  
    except OtherProvidersException as e:
        raise HTTPException(status_code=404, detail=str(e))
    except ApkAnalyzerError as e: 
        raise HTTPException(status_code=401, detail=str(e))      
    except Exception as e:
        raise HTTPException(status_code=500, detail= f"Unknown Error: {e}")
    


async def create_classification_task(file: UploadFile):
    contents = await file.read()
    if is_apk(contents):    
        classification_model = get_file_details(contents)
        classification_model = add_other_providers_to_model(classification_model)
        return classification_model
    else:
        raise NonApkFileError(f"Inserting a non-apk file: {file.filename}")

@app.post("/scan_file_batch")
async def upload_multiple_files(files: List[UploadFile] = File(...)):
    try:    
        tasks = []
        classification_list = []
        for file in files:
            task = asyncio.create_task(create_classification_task(file))
            tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        
        for result in results:
            classification_list.append(result)

        return classification_list
    except NonApkFileError as e:
        raise HTTPException(status_code=400, detail=str(e))    
    except CacheException as e:
        raise HTTPException(status_code=401, detail=str(e))  
    except OtherProvidersException as e:
        raise HTTPException(status_code=404, detail=str(e))
    except ApkAnalyzerError as e: 
        raise HTTPException(status_code=401, detail=str(e))      
    except Exception as e:
        raise HTTPException(status_code=500, detail= str(e))
    