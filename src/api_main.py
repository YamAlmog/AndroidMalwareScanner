import pandas as pd
from typing import Optional
import os
from fastapi import FastAPI, File, UploadFile, HTTPException
from errors import ApkAnalyzerError
from apk_analyzer import ApkAnalyzer
from classifier import Classifier
from models import ClassificationResponse, Metadata
from utils import tracer, get_file_hash
from typing import List
from errors import CacheException, ExternalProviderError, NonApkFileError, FileNotFoundError
from redis_cache import RedisCacheManager
from other_providers import OtherProviders
import logging
import asyncio
from dotenv import load_dotenv

if os.getenv("DOCKER_ENV"):
    load_dotenv(".docker.env")
else:
    load_dotenv(".env")

logging.basicConfig(filename='app.log',level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

app = FastAPI()

COMMON_PERMISSIONS_PATH = os.getenv('COMMON_PERMISSIONS_PATH_FROM_SRC')

VT_API_KEY = os.getenv('VT_API_KEY')
VT_URL = os.getenv("VT_URL")
KASPERSKY_API_KEY = os.getenv('KASPERSKY_API_KEY')

most_common_permissions = pd.read_csv(COMMON_PERMISSIONS_PATH, header=None)
permissions_list = most_common_permissions[0].tolist()[1:]

# Retrieve environment variables
HOST = os.getenv("REDIS_HOST")
PORT = int(os.getenv("REDIS_PORT"))
CSV_PATH = os.getenv('CSV_PATH_FROM_SRC')

# initial class objects:
apk_analyzer = ApkAnalyzer(permissions_list)
redis_cache = RedisCacheManager(HOST, PORT)


def get_file_details(file_content):
    file_hash = get_file_hash(file_content)
    cache_result = redis_cache.get_redis_db_file_details(file_hash)  

    if cache_result:
        return cache_result   
    else:
        file_feature_vector = apk_analyzer.get_feature_vector(file_content)
        file_classifier = Classifier(CSV_PATH)
        classification, probability = file_classifier.predict_file(file_feature_vector)
        permissions = apk_analyzer.get_file_permissions(file_content)
        permissions = str(permissions).replace('\'', '')
        # Item doesn't exist, create Classification model and insert it into redis_cache
        file_metadata = Metadata(file_hash = file_hash, permissions = permissions)
        classification_model = ClassificationResponse(verdict = classification, probability = probability, metadata = file_metadata)
        redis_cache.insert_file_details_to_redis_db(file_hash, classification_model)
    return classification_model



@tracer
@app.post("/scan_file")
async def upload_user_file(file: UploadFile = File(...), metadata: Optional[bool]=False):
    try:
        contents = await file.read()
        if ApkAnalyzer.is_apk(contents):
            classification_model = get_file_details(contents)
            # return response
            if metadata == True:     
                return classification_model.model_dump(exclude_none=True) # drop none values from response
            else:
                classification_model.metadata = None
                return classification_model.model_dump(exclude_none=True) # drop none values from response
        else:
            raise NonApkFileError(f"Inserting a non-apk file: {file.filename}")
    except NonApkFileError as e:
        raise HTTPException(status_code=400, detail=str(e))    
    except CacheException as e:
        raise HTTPException(status_code=400, detail=str(e))    
    except OSError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except ApkAnalyzerError as e: 
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail= f"Unknown Error: {e}")

@tracer
@app.post("/get_permissions")
async def get_file_permissions(file: UploadFile = File(...)):
    try:
        contents = await file.read()
        if ApkAnalyzer.is_apk(contents):
            permissions = apk_analyzer.get_file_permissions(contents)
            return {'File Permissions': permissions}
        raise NonApkFileError(f"Inserting a non-apk file: {file.filename}")
    except NonApkFileError as e:
        raise HTTPException(status_code=400, detail=str(e))    
    except ApkAnalyzerError as e: 
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail= f"Unknown Error: {e}")


@tracer
@app.get("/scan_file_with_hash")
async def get_user_file(file_hash: str):
    try:
        file_details = redis_cache.get_redis_db_file_details(file_hash)
        if file_details:
            return file_details.model_dump(exclude_none=True) # drop none values from response
        else:
            raise FileNotFoundError("File hash not found")
    except FileNotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))      
    except CacheException as e:
        raise HTTPException(status_code=400, detail=str(e))     
    except Exception as e:
        raise HTTPException(status_code=500, detail= f"Unknown Error: {e}")



@tracer
@app.post("/scan_with_other_providers")
async def scan_file_with_other_providers(file: UploadFile = File(...)):
    try:
        contents = await file.read()
        
        if ApkAnalyzer.is_apk(contents):    
            classification_model = get_file_details(contents)
        
            classification_model = await OtherProviders.add_other_providers_to_model(classification_model, VT_API_KEY, VT_URL, KASPERSKY_API_KEY)
            return classification_model.model_dump(exclude_none=True) # drop none values from response
        else:
            raise NonApkFileError(f"Inserting a non-apk file: {file.filename}")
    except NonApkFileError as e:
        raise HTTPException(status_code=400, detail=str(e))    
    except CacheException as e:
        raise HTTPException(status_code=400, detail=str(e))  
    except ExternalProviderError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except ApkAnalyzerError as e: 
        raise HTTPException(status_code=400, detail=str(e))      
    except Exception as e:
        raise HTTPException(status_code=500, detail= f"Unknown Error: {e}")
    


async def create_classification_task(file: UploadFile):
    contents = await file.read()
    if ApkAnalyzer.is_apk(contents):    
        classification_model = get_file_details(contents)
        classification_model = await OtherProviders.add_other_providers_to_model(classification_model, VT_API_KEY, VT_URL, KASPERSKY_API_KEY)
        return classification_model.model_dump(exclude_none=True)
    else:
        raise NonApkFileError(f"Inserting a non-apk file: {file.filename}")


@tracer
@app.post("/scan_file_batch")
async def upload_multiple_files(files: List[UploadFile] = File(...)):
    try:    
        tasks = []
        classification_list = []
        for file in files:
            task = asyncio.create_task(create_classification_task(file))
            tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        
        for result in results:
            classification_list.append(result)

        return classification_list
    except NonApkFileError as e:
        raise HTTPException(status_code=400, detail=str(e))    
    except CacheException as e:
        raise HTTPException(status_code=400, detail=str(e))  
    except ExternalProviderError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except ApkAnalyzerError as e: 
        raise HTTPException(status_code=400, detail=str(e))      
    except Exception as e:
        raise HTTPException(status_code=500, detail= str(e))
    


@tracer
@app.get("/clear_redis_cache")
async def clear_redis():
    try:
        redis_cache.clear_redis_cache()
        return "Redis cache successfully emptied."
    except FileNotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))      
    except CacheException as e:
        raise HTTPException(status_code=400, detail=str(e))     
    except Exception as e:
        raise HTTPException(status_code=500, detail= f"Unknown Error: {e}")
