import pandas as pd
from statistics import mode
from enum import Enum
from sklearn.svm import SVC
from sklearn.ensemble import RandomForestClassifier
from sklearn.neighbors import KNeighborsClassifier
from typing import Tuple

class Verdict(str, Enum):
    Malicious = 'Malicious'
    Benign = 'Benign'


class Classifier():
    def __init__(self, csv_path:str) -> None:
        self.dataframe = pd.read_csv(csv_path)
        self.models = []

        self.fit_models()


    def process_data(self) -> pd:
        # remove the column of files hash name because it is not informative for me
        self.dataframe = self.dataframe.drop('hash', axis=1)

        # split label from data
        y = self.dataframe['label']
        X = self.dataframe.drop('label', axis=1)
        
        return X, y


    def fit_models(self)-> None:
        X, y = self.process_data()
        
        knn_classifier = KNeighborsClassifier(algorithm='auto', n_neighbors=1, weights='uniform')
        # fit knn model to train set
        knn_classifier.fit(X, y)

        rf_classifier = RandomForestClassifier(criterion='gini', max_depth=10, min_samples_split=2, n_estimators=80)
        # fit rf model to train set    
        rf_classifier.fit(X, y)

        svm_classifier = SVC(C=3, kernel='rbf')
        # fit svm model to train set 
        svm_classifier.fit(X, y)
        
        self.models = [knn_classifier, rf_classifier, svm_classifier]


    def predict_file(self, file_features_vector) -> Tuple[Verdict,float]:

        predict_result = []
        for model in self.models:
            result = model.predict([file_features_vector])
            predict_result.append(result[0])
        
        # calculate the probability use rf model
        rf_model = self.models[1]
        malicious_prob = rf_model.predict_proba([file_features_vector])
    
        # Determine the majority using the mode function
        majority_prediction = mode(predict_result)
        
        if majority_prediction == 1:
            majority_prediction = Verdict.Malicious
            return majority_prediction, round(malicious_prob[0][1], 3)
        else:
            majority_prediction = Verdict.Benign
            return majority_prediction, round(1-malicious_prob[0][1], 3)
        